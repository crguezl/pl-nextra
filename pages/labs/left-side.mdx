---
title: "Functions on the left side of an assignment"
key: left-side
published: true
date: 2024/04/01
delivery: 2024/04/11
display: "hidden"
campus: ""
classroom: "https://classroom.github.com/classrooms/153934884-ull-esit-pl-2324/assignments/left-side"
rubrica:
  - El paquete está publicado en GitHub Registry
  - Se comprueba que el módulo npm se instala desde el GitHub Registry y funciona
  - Probar que el ejecutable queda correctamente instalado, puede ser ejecutado con el nombre publicado y produce salidas correctas
  - "Opciones en línea de comandos (-o, -V, -h, etc.)"
  - "Traduce correctamente los asignaciones a funciones"
  - Las operaciones son simétricas
  - Los mensajes de error para operaciones sobre tipos incorrectos son adecuados
  - Los operadores de comparación son soportados por las string
  - Ha añadido tests suficientes, documentación y cubrimiento
  - "Se publica la documentación usando un static generator, API docs y Covering" 
  - Se ha añadido el enlace a las GH pages en el "About" del repo
  - Si se han usado herramientas AI se deberá  <b>incluir en el <code>README.md</code> una sección sobre como fueron utilizadas. En caso contrario se debe declarar que no se han usado</b>.
  - En la misma sección el alumno indicará su compromiso a no hacer uso de la IA que pueda impedir su crecimiento académico personal o impedirle comprender los conceptos de esta práctica

videos: [  ]

video20240313:
  date: "2024/03/13"
  url: "https://youtu.be/R_Eg5LcJxF4"
  id: "R_Eg5LcJxF4"
  comment: "Clase del 13/03/2024. Building the Egg AST for 'ID apply'. Adding loops to the calculator language"

video20240318: 
  date: "2024/03/18"
  url: "https://youtu.be/ESRZvz0IzQg"
  id: "ESRZvz0IzQg"
  comment: "Adding loops to the calculator language. Building a lexer generator"

video20240320:
  url: "https://youtu.be/d3TTS5ZgddA"
  id: "d3TTS5ZgddA"
  date: "2024/03/20"
  comment: "Clase del 20/03/2024. Your workflow when adding a new feature to a translator"
---
import { Callout } from 'nextra/components'
import Videos from '@/components/videos'


## Goal: Functions on the left side of an assignment

In the calculator language, the left side of an assignment only an ID is allowed. We want to extend the language to allow the modification of functions.

### Introduction

We want to extend the language so that on the left side of an assignment you can have a function modification. For example, the following code should be valid:

```js showLineNumbers {2,3} filename="test/data/input/fun.calc"
f = fun(x) { x + 1 },
f(0+2) = 8, 
f(1+3) = 1000,
write(f(0)), # 1
write(f(2)), # 8
write(f(4))  # 1000
```

The translation of the former code can be s.t. like the following:

```js showLineNumbers /memoize/ filename="test/data/expectedjs/fun.js" copy
➜  functions-solution git:(array-map) bin/calc2js.mjs test/data/input/fun.calc 
#!/usr/bin/env node
const { Complex, memoize, write } = require("/Users/casianorodriguezleon/campus-virtual/2223/pl2223/practicas/functions/functions-solution/src/support-lib.js"); 
/* End of support code */
 
let $f;

(((($f = function($x) {
    return $x.add(Complex("1"));
}, 
$f = memoize($f, [Complex("0").add(Complex("2"))], Complex("8"), 0)), 
$f = memoize($f, [Complex("1").add(Complex("3"))], Complex("1000"), 0)), 
write($f(Complex("0")))), 
write($f(Complex("2")))), 
write($f(Complex("4")));
```
When you run the former code you get the following output:
```
➜  functions-solution git:(array-map) bin/calc2js.mjs test/data/input/fun.calc | node
1
8
1000
```

### Modifying a function with nested calls on the left side

let's consider the following example in which a nested call occurs in the left hand side of the assignment:

```js showLineNumbers {3} filename="test/data/input/fun-on-the-left-side.calc"
➜  functions-solution git:(left-side) cat test/data/input/fun-on-the-left-side.calc            
f = fun(x) { fun(y) { x + y } },
f(2)(3) = 8, 
write(f(2)(3)),  # 8
write(f(2)(5)),  # 7
write(f(3)(1)),  # 4
write(f(9)(2))   # 11
```

The former code modifies the code of the function `$f`  created in the first assignment

```js showLineNumbers {16} filename="test/data/expectedjs/fun-on-the-left-side.js"
➜  functions-solution git:(left-side) ✗ bin/calc2js.mjs test/data/input/fun-on-the-left-side.calc
#!/usr/bin/env node
const { memoize, Complex, write } = require("/Users/casianorodriguezleon/campus-virtual/2223/pl2223/practicas/functions/functions-solution/src/support-lib.js"); 
/* End of support code */
 
let $f;
(
    (
        (
            (
                $f = function($x) {
                    return function($y) {
                        return $x.add($y);
                    };
                }, 
                $f = memoize($f, [Complex("2"), Complex("3")], Complex("8"), 0)
            ), 
            write($f(Complex("2"))(Complex("3"))) // 8
        ), 
        write($f(Complex("2"))(Complex("5")))  // 7
    ), 
    write($f(Complex("3"))(Complex("1")))  // 4
), 
write($f(Complex("9"))(Complex("2"))); // 11
```

## Nested calls on the left side and a function on the right side

In this example the assignment on line 6 modifies the function `f` so that `f(1)` returns a function that squares its argument:

```js showLineNumbers filename=test/data/input/fun-on-the-left-side-3.calc {6}
f = fun(x) { 
      fun(y) { 
        fun (z) { x + y + z }
    }
},
f(1) = fun(y) { y*y },
print(f(1)(3)),   #  9
print(f(2)(3)(5)) # 10 
```

Is for that reason that `f(1)(3)`  is the square of `3` and `f(2)(3)(5)` is `2 + 3 + 5` that is `10`.

### The memoize function

As we have seen the `memoize` function receives 
1. a function `$f` to memoize,
2. an array of arguments `cacheArgs` like `[ Complex("2"), Complex("3")]` that correspond to the source nested calls `f(2)(3)`
3. the value to return `Complex("8")` in the former example
4. the index `i` to recursively traverse the `cacheArgs` array.

f(1)(2) = 8

```js showLineNumbers filename="src/memoize.js" copy
function memoize(f, cacheArgs, cacheValue, i) {
    let cacheArgument = cacheArgs[i];

    return function (...args) {
        let auxF = f;

        if (cacheArgument == null) return cacheValue; //?
        if (args[0].equals(cacheArgument)) {
            auxF = f(...args);
            if (cacheArgs.length === i + 1) return cacheValue;
        }
        if (args[0].equals(cacheArgument) && cacheArgs.length > i + 1) {
            return memoize(auxF, cacheArgs, cacheValue, i + 1)
        }
        return auxF(...args);
    }
}

module.exports = { memoize };
```

### References on memoization

See 
1. My old notes in [memoization](https://crguezl.github.io/apuntes-ruby/node167.html) of the `fib`onacci function in Ruby and 
2. The [wikipedia section on Memoization](https://en.wikipedia.org/wiki/Memoization).
3. [Memoization of the require in Egg](https://crguezl.github.io/ull-esit-1617/_book/practicas/practica-egg-4.html)
4. [memoize](https://github.com/sindresorhus/memoize) npm package by Sindre Sorhus
5. [Memoization of Multi-Parametered Functions in JavaScript](https://medium.com/@joedski/memoization-of-multi-parametered-functions-in-javascript-8508e89ba545) by Joseph Sikorski. Jul 14, 2017

## Goal: Array notation for functions and otherwise

The notation

```js
a = [4;7;9 ... 0]
```

defines `a` as a function such that `a(0)` returns `4`, `a(1)` returns `7`, and `a(2)` returns `9` and otherwise 
returns `0`.

If the `... expression` is not present, the function returns an special object called 
`null` for any argument not explicitly defined.

```js showLineNumbers filename: test/data/input/arr.calc 
a = [4+2;5+3i;9-i],
print(a(0)), # { re: 6, im: 0 }
a(1) = 333,  
print(a(1)), # { re: 333, im: 0 }
print(a(9)), # null
print(a)     #  { re: 6, im: 0 }, { re: 333, im: 0 }, { re: 9, im: -1 } ]
```

The former code translates to

```js showLineNumbers filename: test/data/expectedjs/arr.js {14-18}
➜  functions-solution git:(array-map) ✗ bin/calc2js.mjs test/data/input/arr.calc | npx prettier --parser babel
#!/usr/bin/env node
const {
    arr,
    Complex,
    print,
    memoize
} = require('/Users/casianorodriguezleon/campus-virtual/2223/pl2223/practicas/functions/functions-solution/src/support-lib.js');

/* End of support code */

let $a;

((((($a = arr(
    Complex('4').add(Complex('2')),
    Complex('5').add(Complex('3i')),
    Complex('9').sub(Complex('i'))
)),
print($a(Complex('0')))),
($a = memoize($a, [Complex('1')], Complex('333'), 0))),
print($a(Complex('1')))),
print($a(Complex('9')))),
    print($a);
```

## Hashes/Maps/Objects

Proposed syntax for hashes/maps:

```js
a = { 4: 5; 7: 3i; "hello": 6 ... 0}
```

meaning a function that `a(4) = 5`, `a(7) = 3i`, `a("hello") = 6` and otherwise `a(x) = 0` for all `x`.

An alternative to explore/study is to consider the introduction of the `meth` keyword that will define a functions that usea the "object" as a context. For example, the following code:

```js
b = { "x": 5;  "add": meth(z) { x + z} },
f("add")(3) # 8
```

## null object 

Introduce `null` as an extension of `0` and the empty string `""` so that it holds the following properties:

```js
null + 4 == 4,
null + "hello" == "hello", # this is not the JS behavior
null * 4 == 0,
4 - null == 4,
fun(x) { x + 1 } * null # is the same as fun(x) { 0 },
null && true == false,
```

Notice that if `a` is a function like in the former example `a * null` is the function `a(x) = 0` for any `x`.

## Videos

import {frontmatter} from '@/src/frontmatter'

### 2024/03/20

{ frontmatter().video20240320.comment }

<Videos ids={ [frontmatter().video20240320.id] }></Videos>


{frontmatter().video20240313.comment}

<Videos ids={[frontmatter().video20240313.id]}></Videos>

{frontmatter().video20240318.comment}

<Videos ids={[frontmatter().video20240318.id]}></Videos>

## Pruebas, Covering e Integración Continua

Escriba las pruebas, haga un estudio de cubrimiento usando [c8](https://github.com/bcoe/c8) y añada integración continua usando [GitHub Actions](/topics/introduction-to-javascript/github-actions).

Lea las secciones [Testing with Mocha](/topics/introduction-to-javascript/mocha#mocha) y [Jest](/topics/introduction-to-javascript/jest).


## Publishing a package to the GitHub Registry

See the chapter [Publishing a package to the GitHub Registry](/topics/introduction-to-javascript/creating-and-publishing-npm-module#publishing-a-package-to-the-github-registry) and the sections

* [Configure npm](/topics/introduction-to-javascript/creating-and-publishing-npm-module#configure-npm)
* [What are scopes?](/topics/introduction-to-javascript/creating-and-publishing-npm-module#what-are-scopes)
* [What is Github Registry?](/topics/introduction-to-javascript/creating-and-publishing-npm-module#what-is-github-registry)
* [Other ways to set the Scope](http://localhost:3000/topics/introduction-to-javascript/creating-and-publishing-npm-module#other-ways-to-set-the-scope)

One  way to set GitHub as the registry is to add a `publishConfig` field to your `package.json` file

```json filename="package.json"
{
  "name": "@ull-esit-pl-2324/functions-name-ape1-ape2-aluXXX",
  "version": "1.2.0",
  "description": "A lab for PL. Adding Functions to our Calculator",
  "main": "src/transpile.js",
  "bin": {
    "calc2js": "./bin/calc2js.js"
  },
  "publishConfig": {
    "registry": "https://npm.pkg.github.com"
  },
  ...
}
```

I noticed many of you are having a hard time trying to publish the module to the GitHub Package Registry. 

This class 2023/03/14 from 18:03 to to 35:00 may help to overcome the gotchas when publishing a private npm module in the github package registry.

<Videos ids={frontmatter().videos}></Videos>

- Start to talk about publishing a module at minute 18:03. 
- How to get the GitHub token at minute 19:58
- Providing the token to the npm client at minute 23:00
- Issuing `npm publish` at minute 23:52
- Associating the GitHub Organization ULL-ESIT-PL-2324 as a scope to the github registry at minute 28:13
- From minute 34:25 and on, we discuss how to build a web site using a static generator like Vuepress and how to deploy it to GitHub Pages.


## Documentación

[Documente](/topics/introduction-to-javascript/documentation)
el módulo incorporando un `README.md` y la documentación de la función exportada usando [JsDoc](/topics/introduction-to-javascript/documentation).
Lea la sección [Documenting the JavaScript Sources](/topics/introduction-to-javascript/creating-and-publishing-npm-module#documenting-the-javascript-sources)

## Rubric

import Rubric from '@/components/rubric'

<Rubric rubric={frontmatter().rubrica} />

## {frontmatter().key} Repos

import ReposForLab from '@/components/repos-for-lab'

<ReposForLab lab={frontmatter().key} />


## References

* COMP442/6421 - Compiler Design - week 8 - AST traversal using the Visitor pattern. Concordia University, Montreal , Canada. 2022
  *  <Videos ids={["enG0blJXbaY"]}></Videos>
* Compiler Design Module 34 : Semantic Analysis Introduction to Scope. IITI Delhi. Compiler AI Labs. 2020
  *  <Videos ids={["-OTt9IRBJKw?si=jSgET5RhS4-gXla6"]}></Videos>
* Compiler Design Module 35 : Semantic Analysis as Recursive Descent over AST. IITI Delhi. Compiler AI Labs. 2020
  *  <Videos ids={["PNS7nxSi608"]}></Videos>
* [ast-types](/topics/tree-transformations/ast-types): See the scope section
* [recast](/topics/tree-transformations/jscodeshift-recast) 

### Polymorphism

See the notes by Casiano Rodríguez León. 2011:

1. [Sobrecarga, Polimorfismo e Inferencia de Tipos](https://campusvirtual.ull.es/ocw/pluginfile.php/2321/mod_resource/content/0/perlexamples/node295.html#SECTION001810040000000000000) 
2. [Expresiones de Tipo, Sistemas de Tipos y Comprobadores de Tipos](https://campusvirtual.ull.es/ocw/pluginfile.php/2321/mod_resource/content/0/perlexamples/node295.html#SECTION001810010000000000000)]
3. [Equivalencia de Expresiones de Tipo](https://campusvirtual.ull.es/ocw/pluginfile.php/2321/mod_resource/content/0/perlexamples/node295.html#SECTION001810050000000000000)
4. [Un Lenguaje con Funciones Polimorfas](https://campusvirtual.ull.es/ocw/pluginfile.php/2321/mod_resource/content/0/perlexamples/node315.html)
